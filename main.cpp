//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <fstream>
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;

#define IM_W 640
#define IM_H 480
#define OFF_W 5
#define OFF_H 20

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat resultat;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard


    //ranges, mis en global car ne changent jamais et utilisées par plusieurs fonctions
    const float huerange[] = {0, 180};
    const float satrange[] = {0, 256};
    const float *ranges[] = {huerange, satrange};




void help();
void processVideo();
using namespace cv;
cv::VideoCapture capture;

int main(int argc, char* argv[])
{


    capture=cv::VideoCapture(0);
    if(!capture.isOpened())
    {
        std::cerr<<"Failed to open Camera"<<std::endl;
        exit(1);
    }

    //create GUI windows
 
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(5,2); //MOG2 approach
   
    processVideo();
   
    //destroy GUI windows
    destroyAllWindows();
}



void show_2d_hist(MatND &hist, char * name, int huebins = 30, int satbins = 32){
    double maxVal = 0;
    minMaxLoc(hist, 0, &maxVal, 0, 0); //on trouve la valeur max de l'histogramme

    int scale = 10;
    Mat histImg = Mat::zeros(satbins * scale, huebins * 10, CV_8UC3);

    for( int h = 0; h < huebins; h++ )
        for( int s = 0; s < satbins; s++ )
        {
            float binVal = hist.at<float>(h, s);
            int intensity = cvRound(binVal*255/maxVal);
            rectangle( histImg, Point(h*scale, s*scale),
                        Point( (h+1)*scale - 1, (s+1)*scale - 1),
                        Scalar::all(intensity),
                        CV_FILLED );
        }
    namedWindow(name, 1);
    imshow(name, histImg);
}


MatND hue_saturation_histogram(Mat &image, int huebins = 30, int satbins = 32)
{
    Mat image_hsv; //structure pour recevoir l'image convertie en hsv

    cvtColor(image, image_hsv, CV_BGR2HSV); //conversion de l'image en hsv

    int histSize[] = {huebins, satbins};

    const int channels[] = {0, 1};

    MatND hist;

    calcHist(   &image_hsv, 1, channels, Mat(), //pas de masque
                hist, 2, //2 dimensions
                histSize, ranges
                );

    return hist;
}



MatND normalized_hue_saturation_histogram(MatND &hist){
    MatND n_hist;
    normalize( hist, n_hist, 0, 255, NORM_MINMAX, -1, Mat() );
    return n_hist;
}

MatND hue_saturation_backprojection(Mat image, MatND hs_hist, int huebins = 50, int satbins = 52){ //mat: image RGB, hs_hist: histogramme H-S normalisé
    Mat image_hsv;
    cvtColor(image, image_hsv, CV_BGR2HSV);

    int channels[] = { 0, 1 };

    MatND backproj;
    calcBackProject(&image_hsv, 1, channels, hs_hist, backproj, ranges, 1, true);
    return backproj;
}

void draw_sub_window(int x, int y, Mat &parent, Mat child, char *text){

    child.copyTo(parent(cv::Rect( x * (OFF_W + IM_W) + OFF_W, y * (OFF_H + IM_H) + OFF_H, IM_W, IM_H)));
    putText(parent, text, Point(x * (OFF_W + IM_W) + OFF_W, y * (OFF_H + IM_H) + OFF_H - 5), FONT_HERSHEY_PLAIN, 1, Scalar(0, 0, 255));


}

void processVideo() {
    //create the capture object
    Mat global_im = Mat( 2 * (IM_H + OFF_H), 2 * (IM_W + OFF_W), CV_8UC3);
    Size glob_size = global_im.size();
    Mat sub_mat = Mat(IM_W, IM_H, CV_8UC3);
    int label_nb;
    Mat hand = cv::imread("main3.png");
    Mat im_hsv;
    vector<Mat> hsv_channels;
    Mat smoothed_frame;
    MatND hand_hs_hist = hue_saturation_histogram(hand);
    MatND backproj;
    Mat background;
    Mat thresd_backproj;
    Mat labels;
    Mat label_img = Mat(IM_H, IM_W, CV_8UC3);
    Mat connect_stats;
    Mat centroids;
    std::vector<Vec3b> colors;
    Mat frame_half;
            Mat mat_test = Mat(IM_H, IM_W, CV_8U);
    vector<Point> points_capture;
    vector<Mat> hand_subdivisions;
    vector<MatND> hand_histograms;
    vector<MatND> backprojections;

    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;

    bool hand_captured = false;
    Point taille_captures = Point(10, 10);
    //read input data. ESC or 'q' for quitting

    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

         medianBlur ( frame, frame, 9);

        /***************************************/
        label_img = frame;

        keyboard = waitKey( 30 );
        if(hand_captured){
            char test[] = "a";
            char test2[] = "z";
            int i = 0;


            for(auto m : hand_subdivisions){
               
                test[0] = 'a' + (char)i;
                test2[0] = 'u' + (char)i;
                Mat image2;
                Mat image3 = Mat(IM_H, IM_W, CV_8UC3);
                int delta = 10;
                Vec3b c = (m.at<Vec3b>(5, 5));
               // std::cout << c << std::endl;
                inRange(frame, cv::Scalar(c[0] - delta, c[1] - delta, c[2] - delta), cv::Scalar(c[0] + delta, c[1] + delta, c[2] + delta), image2);
                image3.setTo(cv::Scalar(c[0] - delta, c[1] - delta, c[2] - delta));
                /*imshow(test, m);
                imshow(test2, image3);*/
                if(i == 0) mat_test = image2;
                else mat_test += image2;
                i++;

                
            }
            cv::Mat sel = cv::getStructuringElement(MORPH_ELLIPSE, cv::Size(9,9));
            //dilate(mat_test, mat_test, sel);
            imshow("seuillages", mat_test);

            label_nb = connectedComponentsWithStats(mat_test, labels, connect_stats, centroids, 8, CV_32S);

        }

           sub_mat = frame;
            Point p = Point(10, 10);
         
            int off_x = 10, off_y = 15, rect_w = 10, rect_h = 10;
            Point start_point = Point(100, 100);

            //rectangle(frame, Point(10, 10), Point(200, 300), Scalar(0, 0, 255));

            rectangle(frame, start_point + Point(off_x, -off_y), start_point + Point(off_x, -off_y) + Point(10, 10), Scalar(0, 0, 255));
            points_capture.clear();
            for(int i = 0; i < 4; i += 1){
                for(int j = 0; j < 7; j+= 1){
                    Point p1 = start_point + Point(i * off_x, j * off_y);
                    points_capture.push_back(p1);
                    Point p2 = p1 + Point(rect_w, rect_h);
                    rectangle(frame, p1, p2, Scalar(0, 0, 255));    
                }
                
            }

        imshow("frame", frame);

        Mat objet = Mat(IM_H, IM_W, CV_8UC1);
        objet = 0;
        if(hand_captured){
            int biggest_label = 1, max_area = connect_stats.at<int>(1, CC_STAT_AREA);
            for(int label = 2; label < label_nb; label++){
                int area = connect_stats.at<int32_t>(label, CC_STAT_AREA);
                if(area > max_area){
                    biggest_label = label;
                    max_area = area;
                }
            }
            for(int j = 0; j < IM_W; j++){
                for(int i = 0; i < IM_H; i++){
                    int label = labels.at<int32_t>(i, j);
                    int area = connect_stats.at<int32_t>(label, CC_STAT_AREA);
                    if(label == biggest_label)label_img.at<Vec3b>(i, j) = {128, 0, 0};
                    if(label == biggest_label)objet.at<char>(i, j) = 255;
                    else objet.at<char>(i, j) = 0;
                }
            }

             findContours( objet, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
           /* for(auto c:contours){
                std::cout << c[0] << " " << c[1] << std::endl;
            }*/
             for( int i = 0; i< contours.size(); i++ )
            
            {
                 drawContours( label_img, contours, i, {0, 0, 255}, 1, 8, vector<Vec4i>(), 0, Point() );
            }

            vector<vector<Point> >hull( 1 );
            convexHull( Mat(contours[0]), hull[0], false ); 
            drawContours( label_img, hull, 0, {0, 255, 0}, 4, 8, vector<Vec4i>(), 0, Point() );

            imshow("img", label_img);
          
           // smoothed_frame.release();
            resultat.release();
            backproj.release();
            thresd_backproj.release();
        }

        //std::cout << "test\n"//
        if((char)keyboard == 'a'){
            std::cout << "ecriture\n";
            cv::imwrite("test.png", frame);
        }else if((char)keyboard == 'b'){
            std::cout << labels;
        }else if((char)keyboard == 's' && !hand_captured){
            hand_subdivisions.clear();
            Point taille_captures = Point(100, 100);
            int j = 0;
            for(auto p : points_capture){
                Mat sample = Mat(frame, cv::Rect(p, p + taille_captures));
                sample = sample.clone();
                medianBlur ( sample, sample, 15);
                hand_subdivisions.push_back(sample);
                colors.push_back(sample.at<Vec3b>(5, 5));

                //imshow("test", sample);
                j++;
               // std::cout << sample.at<Vec3b>(5, 5) << std::endl;
            }

            
            hand_histograms.clear();  
            int i = 0;       
            char test[] = "a";   
            for(auto m : hand_subdivisions){
                test[0] = 'a' + (char)i;
               // imshow(test, m);
         //       hand_histograms.push_back(hue_saturation_histogram(m));
                i++;
            }  
            hand_captured = true;
            std::cout << "cap\n";
            keyboard = 'r';
        }

    

    }
    std::ofstream f;
        f.open("test.txt");
        f << backproj << std::endl;
        f.close();
    //delete capture object
    capture.release();
}
